# The Lobby Platform

## Motivation

...

### Design

...

### Crucial requirements

...

### Limitations

...

## Technical Details

In the following section, technical details about the chosen implementation and technical decisions are presented.

### Architecture
To make the process of finding other players as easy as possible we decided to implement the lobby platform as a web application so that users can simply open the lobby platform in a browser. The web application is structured with a client-server architecture, meaning the application consists of two parts: a server and a client. The server is written in Python and the client in HTML, CSS, and JavaScript, or more specifically TypeScript. The client is implemented as a single-page application (SPA) whereas the initial design with HTML and CSS was taken from a [Traversy Media tutorial](https://github.com/bradtraversy/chatcord).

The overall principle by which the application operates is that one or multiple users who interact with their respective browsers can be considered clients. These clients initially request an HTML document and additional resources as soon as the URL of the lobby platform is entered. A user's browser receives the requested document and resources like CSS and JavaScript files back from the server and processes them so that the single page application is displayed to the user. This allows the user to enter a user name or send chat messages. These or similar user actions will trigger the sending of messages to the server. The server then decides what to do with these messages.

For example, two things happen when a yet-unknown user enters a name and clicks the "Join Chat" button. First, a WebSocket connection between the client and server is established. Second, the client sends a 'join' message to the server. The server then checks all rooms for an empty seat and assigns the user to the next available room. All clients that are a member of this room are informed about this new user by sending them a 'user-connected' message with additional data. For example, the text "USER_XY just joined the chat!" will be shown to all members of the room. The disconnection of users or the sending and receiving of chat messages are propagated in a similar fashion.

For sending WebSocket messages the library [Socket.IO](https://socket.io/) was used. For the client, the [JavaScript version](https://socket.io/docs/v4/client-installation/) was used and for the server the Python [Flask-SocketIO](https://flask-socketio.readthedocs.io/en/latest/) one. Both are compatible with each other and implement the same API. The library is a relatively thin layer above the bare bone WebSocket API which makes it easier to implement real-time communication features. For example, room functionalities for adding clients to a room or broadcasting messages only to clients of a particular room are already provided. While the server uses the flask framework as the only mention-worthy package, the client uses several technologies.

On the client, TypeScript is used, which is a superset of JavaScript and allows us to basically write JavaScript with additional type annotations. These kinds of static types allow tools in the background to show immediate error feedback in an IDE while developing. Thereby errors are detected early on and our confidence in the correctness of our code is higher. Additional productivity features like better autocompletion increase the development experience. The code is split into 4 files: index.ts, LobbyMachine.ts, UpdateUI.ts, and Constants.ts whereas the latter simply defines constant variables.

LobbyMachine.ts contains a finite state machine and the majority of the application logic. The state machine is implemented with the library XState and ensures that the application is always in a single state. This guarantees that only the exactly defined user interactions are possible. Furthermore, index.ts registers event listeners and creates a service of the state machine so that any user interaction events are forwarded to the state machine. Depending on its current state the state machine then decides if a transition to the next state happens or if any side-effects should be executed. In our case, side-effects are updates to the user interface like displaying a chat message. They are located in UpdateUI.ts.

### Server

On the server-side, a new ‘Room’ class was created. This class has several attributes and methods for handling processes that are involved in the joining and disconnecting of users, the display of instructions, and the storage of all messages exchanged so far. Each user message within a specific lobby room, along with additional information necessary to identify messages like the time and user id, is stored within different instances of this class. Before a new user connects to a specific room the chat history, which includes all messages from when the joining user wasn’t present, is distributed to the user. When a user joins the room, other users are notified and the join event is documented within the chat history.

The room class also entails basic logic any chat room needs. Before a user joins a specific chat room the server validates whether the upper limit of players is already reached and therefore needs to create a new room. If the player can join an existing room and the number of players reached the minimum limit to play a game of Escapeling, instructions for the initialization of an Escapeling mission are automatically displayed for all the players within the room. Within each room the first player that joined the lobby is the admin. The instructions for the admin are different compared to other players, as the admin needs to create a new Escapeling mission and share the registration code, which the other players then have to paste into their telegram chat with the Escapeling bot. The optimal number of players for an Escapeling mission is a minimum of 3 players and a maximum of 4, constants were set accordingly.

When a user decides to leave the current room the user can click the ‘Leave Room’-button on the top right, which allows the user to join another room, or just close the browser tab. The server is notified via a socket event and the user is removed from the associated lobby room and the other users are notified about the disconnect via a server message within the chat. The lobby room is then available to be joined by another user. If the admin of a room leaves, the user that joined right after is the new admin, or if no player is left, the admin role is left empty and the next player that joins the room will be assigned.


### Build process & Deployment

To make TypeScript files interpretable for browsers Webpack is used to compile and bundle them into a single optimized JavaScript file. For the configuration of Webpack we used the [webpack-boilerplate](https://github.com/taniarascia/webpack-boilerplate) template by Tania Rascia which already comes with a local development server and a build process to optimize bundling for production. The Webpack loader ts-loader was added so that Webpack is able to compile and bundle TypeScript files. Additional dependencies like `xstate` and `socket.io-client` were added to the package.json as well. For additional information on Webpack refer to [Tania’s tutorial](https://www.taniarascia.com/how-to-use-webpack/) or the [official Webpack documentation](https://webpack.js.org/guides/). The Webpack production built process is also run when the application is deployed to Heroku where the application is hosted on the free tier. The necessary steps for deployment are somewhat documented by [this commit](https://github.com/TobiObeck/escapeling-lobby/commit/8bbeab11db2a4a3d7402ed9a5490994a56880d00). The lobby is publicly available here: [https://escapeling-lobby.herokuapp.com/.](https://escapeling-lobby.herokuapp.com/)

## Outlook

Although the implementation of the lobby platform covers the basic needs and several edge cases for a chat application, there are certain ways to improve the user experience. When the instructions for each user are displayed the chat messages are extended to the lobby-chat until it reaches across the lower screen border. This creates two scroll bars, one within the chat and one for the entire website, which leads to a poor user experience. To fix this issue, different CSS elements have to be changed within the website template, and parts of the messages and instruction text visualization need to be adapted, too. This tedious process wasn’t conducted during development, as the focus was on important aspects of the lobby, like properly handling the disconnect of a user and covering all edge cases that are associated with the disconnect. Another aspect to increase the user experience is that when a user clicks the ‘leave room’ button a warning message like "Are you sure to leave?" should be displayed. This would ensure that the user wants to leave for sure, as re-joining a specific room isn’t possible so far.  

Priority-wise, one problem should be focused on during the improvement of the lobby platform. When the user loses connection to the server (e.g. no internet connection) the user is thrown out of the lobby, but there is no indication for the user that this happened. The ability to send messages or interact with the UI is still working, however, messages or mouse click events are not sent to the server anymore and the client does not receive any web-socket events triggered by the server. One possible solution is to display a popup window with a connection lost message, which gives the user notice about the lost connection, hinders him from interactions with the UI, and should allow the user to reconnect to the same lobby. On the other side, the disconnect event is registered adequately by the server and thus informs other users within the lobby room about it.


...
