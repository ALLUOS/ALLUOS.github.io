# The Lobby Platform

## Motivation

...

### Design

...

### Crucial requirements

...

### Limitations

...

## Technical Details

In the following section, technical details about the chosen implementation and technical decisions are presented.

### Architecture
To make the process of finding other players as easy as possible we decided to implement the lobby platform as a web application so that users can simply open the lobby platform in a browser. The web application is structured with a client-server architecture, meaning the application consists of two parts: a server and a client. The server is written in Python and the client in HTML, CSS, and JavaScript, or more specifically TypeScript. The client is implemented as a single-page application (SPA) whereas the initial design with HTML and CSS was taken from a [Traversy Media tutorial](https://github.com/bradtraversy/chatcord).

The overall principle by which the application operates is that one or multiple users who interact with their respective browsers can be considered clients. These clients initially request an HTML document and additional resources as soon as the URL of the lobby platform is entered. A user's browser receives the requested document and resources like CSS and JavaScript files back from the server and processes them so that the single page application is displayed to the user. This allows the user to enter a user name or send chat messages. These or similar user actions will trigger the sending of messages to the server. The server then decides what to do with these messages.

For example, two things happen when a yet-unknown user enters a name and clicks the "Join Chat" button. First, a WebSocket connection between the client and server is established. Second, the client sends a 'join' message to the server. The server then checks all rooms for an empty seat and assigns the user to the next available room. All clients that are a member of this room are informed about this new user by sending them a 'user-connected' message with additional data. For example, the text "USER_XY just joined the chat!" will be shown to all members of the room. The disconnection of users or the sending and receiving of chat messages are propagated in a similar fashion.

For sending WebSocket messages the library [Socket.IO](https://socket.io/) was used. For the client, the [JavaScript version](https://socket.io/docs/v4/client-installation/) was used and for the server the Python [Flask-SocketIO](https://flask-socketio.readthedocs.io/en/latest/) one. Both are compatible with each other and implement the same API. The library is a relatively thin layer above the bare bone WebSocket API which makes it easier to implement real-time communication features. For example, room functionalities for adding clients to a room or broadcasting messages only to clients of a particular room are already provided. While the server uses the flask framework as the only mention-worthy package, the client uses several technologies.

On the client, TypeScript is used, which is a superset of JavaScript and allows us to basically write JavaScript with additional type annotations. These kinds of static types allow tools in the background to show immediate error feedback in an IDE while developing. Thereby errors are detected early on and our confidence in the correctness of our code is higher. Additional productivity features like better autocompletion increase the development experience. The code is split into 4 files: index.ts, LobbyMachine.ts, UpdateUI.ts, and Constants.ts whereas the latter simply defines constant variables.

LobbyMachine.ts contains a finite state machine and the majority of the application logic. The state machine is implemented with the library XState and ensures that the application is always in a single state. This guarantees that only the exactly defined user interactions are possible. Furthermore, index.ts registers event listeners and creates a service of the state machine so that any user interaction events are forwarded to the state machine. Depending on its current state the state machine then decides if a transition to the next state happens or if any side-effects should be executed. In our case, side-effects are updates to the user interface like displaying a chat message. They are located in UpdateUI.ts.

### Server

...

### Build process & Deployment

To make TypeScript files interpretable for browsers Webpack is used to compile and bundle them into a single optimized JavaScript file. For the configuration of Webpack we used the [webpack-boilerplate](https://github.com/taniarascia/webpack-boilerplate) template by Tania Rascia which already comes with a local development server and a build process to optimize bundling for production. The Webpack loader ts-loader was added so that Webpack is able to compile and bundle TypeScript files. Additional dependencies like `xstate` and `socket.io-client` were added to the package.json as well. For additional information on Webpack refer to [Taniaâ€™s tutorial](https://www.taniarascia.com/how-to-use-webpack/) or the [official Webpack documentation](https://webpack.js.org/guides/). The Webpack production built process is also run when the application is deployed to Heroku where the application is hosted on the free tier. The necessary steps for deployment are somewhat documented by [this commit](https://github.com/TobiObeck/escapeling-lobby/commit/8bbeab11db2a4a3d7402ed9a5490994a56880d00). The lobby is publicly available here: [https://escapeling-lobby.herokuapp.com/.](https://escapeling-lobby.herokuapp.com/)

## Outlook

...