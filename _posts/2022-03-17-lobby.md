# The Lobby Platform

## Motivation

Continuing the Escapeling project, our group reflected on aspects of the platform that could be missing for a better experience. One identified problem was the exclusion of users lacking others to play with. As seen in the flowchart of the original interaction there was the precondition of finding three other people to play with, without any problem (Figure 1). Our design proposal was therefore to implement an alternative step for those who need to find random people to play with. First, we explored the option of whether this could be carried out completely on the same platform, through telegram. However, this turned out to be difficult, since we could not find an effective method to make the current telegram bot do this. Therefore we decided to choose a separate web-based lobby platform where users can communicate with each other and share a link to the Escapeling game.

<img src="https://github.com/ALLUOS/ALLUOS.github.io/raw/master/assets/images//assets/images/flow-chart-lobby.png" class="center">

### Design

Since the project had both time and participant limitations, we set on making an MVP (minimum valuable product) that would include the most crucial features a chat application needs to be able to work. This required some decision-making on what functionalities to include and what functionalities to disregard or consider to be additional tasks if there was any time left.

### Crucial requirements

Exploring the concept of the lobby we discussed functions that would be essential and improve the user experience. We began by deciding that the lobby platform would consist of chat rooms with a one to four person capacity. Each room was also going to be presented with instructions on how to create a game. We also decided on including the option of leaving a chat room and being able to communicate with each other through text messages. 

Since the user experience already involved having to change between the Lobby Plattform and Telegram, we aimed to make the rest of the interface as straightforward as possible. Further, we also knew that the lobby would be used by students of all ages, including children. This resulted in the decision of “easy joining”, where users only had to decide a personal chat name and then press “join”, automatically being assigned to a chat room. The name of a room is randomly chosen between ten different names referring to astronomy.

Another concern was deciding which user to assign responsibility for creating and inviting the others to a game. Once again, we decided to go in a simplistic direction and automatically assign the role of being host to the first person to join a lobby room. This decision helps to avoid unnecessary discussions between users and multiple people taking on the host role simultaneously.

Lastly, we decided that the instructions are not presented to players inside a room until the least necessary number of people that are needed to play the game had joined. This provides a natural decision flow that a game can only be played with a minimum of three persons. These instructions are only presented to the host, the others are presented with information that the host is setting up the game and how to join as soon as the registration code is shared.


### Limitations

Our original design concept involved an option to join a random lobby. The idea was to present an “advanced settings” option, where a user could create their own lobby and allow others to join through a lobby ID. This was discussed to include the rare case of two persons wanting to play together but seeking more participants to be able to play. We decided that this unique case was too uncommon and thus this function was less relevant. In this unique case, the two persons would have to make sure to join at the same time, which increases the chance of joining the same room and we decided this to be sufficient enough for an MVP. 

Another idea was to automate the escapeling bot game creation. Once enough players are in a lobby room, the server requests a new Escapeling Bot session and posts the registration code into the chat. This would support the responsibility of the host, not making that person have to set up the game with the bot all alone. A brief investigation showed that this might be too difficult and time-consuming. We also decided that this was not crucial for the MVP.


## Technical Details

In the following section, technical details about the chosen implementation and technical decisions are presented.

### Architecture
To make the process of finding other players as easy as possible we decided to implement the lobby platform as a web application so that users can simply open the lobby platform in a browser. The web application is structured with a client-server architecture, meaning the application consists of two parts: a server and a client. The server is written in Python and the client in HTML, CSS, and JavaScript, or more specifically TypeScript. The client is implemented as a single-page application (SPA) whereas the initial design with HTML and CSS was taken from a [Traversy Media tutorial](https://github.com/bradtraversy/chatcord).

The overall principle by which the application operates is that one or multiple users who interact with their respective browsers can be considered clients. These clients initially request an HTML document and additional resources as soon as the URL of the lobby platform is entered. A user's browser receives the requested document and resources like CSS and JavaScript files back from the server and processes them so that the single page application is displayed to the user. This allows the user to enter a user name or send chat messages. These or similar user actions will trigger the sending of messages to the server. The server then decides what to do with these messages.

For example, two things happen when a yet-unknown user enters a name and clicks the "Join Chat" button. First, a WebSocket connection between the client and server is established. Second, the client sends a 'join' message to the server. The server then checks all rooms for an empty seat and assigns the user to the next available room. All clients that are a member of this room are informed about this new user by sending them a 'user-connected' message with additional data. For example, the text "USER_XY just joined the chat!" will be shown to all members of the room. The disconnection of users or the sending and receiving of chat messages are propagated in a similar fashion.

For sending WebSocket messages the library [Socket.IO](https://socket.io/) was used. For the client, the [JavaScript version](https://socket.io/docs/v4/client-installation/) was used and for the server the Python [Flask-SocketIO](https://flask-socketio.readthedocs.io/en/latest/) one. Both are compatible with each other and implement the same API. The library is a relatively thin layer above the bare bone WebSocket API which makes it easier to implement real-time communication features. For example, room functionalities for adding clients to a room or broadcasting messages only to clients of a particular room are already provided. While the server uses the flask framework as the only mention-worthy package, the client uses several technologies.

On the client, TypeScript is used, which is a superset of JavaScript and allows us to basically write JavaScript with additional type annotations. These kinds of static types allow tools in the background to show immediate error feedback in an IDE while developing. Thereby errors are detected early on and our confidence in the correctness of our code is higher. Additional productivity features like better autocompletion increase the development experience. The code is split into 4 files: index.ts, LobbyMachine.ts, UpdateUI.ts, and Constants.ts whereas the latter simply defines constant variables.

LobbyMachine.ts contains a finite state machine and the majority of the application logic. The state machine is implemented with the library XState and ensures that the application is always in a single state. This guarantees that only the exactly defined user interactions are possible. Furthermore, index.ts registers event listeners and creates a service of the state machine so that any user interaction events are forwarded to the state machine. Depending on its current state the state machine then decides if a transition to the next state happens or if any side-effects should be executed. In our case, side-effects are updates to the user interface like displaying a chat message. They are located in UpdateUI.ts.

### Server

...

### Build process & Deployment

To make TypeScript files interpretable for browsers Webpack is used to compile and bundle them into a single optimized JavaScript file. For the configuration of Webpack we used the [webpack-boilerplate](https://github.com/taniarascia/webpack-boilerplate) template by Tania Rascia which already comes with a local development server and a build process to optimize bundling for production. The Webpack loader ts-loader was added so that Webpack is able to compile and bundle TypeScript files. Additional dependencies like `xstate` and `socket.io-client` were added to the package.json as well. For additional information on Webpack refer to [Tania’s tutorial](https://www.taniarascia.com/how-to-use-webpack/) or the [official Webpack documentation](https://webpack.js.org/guides/). The Webpack production built process is also run when the application is deployed to Heroku where the application is hosted on the free tier. The necessary steps for deployment are somewhat documented by [this commit](https://github.com/TobiObeck/escapeling-lobby/commit/8bbeab11db2a4a3d7402ed9a5490994a56880d00). The lobby is publicly available here: [https://escapeling-lobby.herokuapp.com/.](https://escapeling-lobby.herokuapp.com/)

## Outlook

...