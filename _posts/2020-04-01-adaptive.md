---
layout: post
title: Adaptive Module
---
# Path Selection Module

## Prior model lacks lead to player self-regulation approach

### The prior self-adjusting adaption model was based on layered proficiency categories

The end of our first semester saw the implementation of a difficulty adaption build upon a refined user proficiency model. In this model the task items were grouped according to their difficulty and their grammatical or lexical categories. The users also got ranked according to this categories both on the more general level (grammar/lexicality) and on the subcategory level (specific grammar/lexical themes). This ranking was used to select items of appropriate difficulty from each category prioritizing weak categories for each player.

### The missing scientific backing and unclear justification are the prior adaption models problems

Together with the proficiency model of the last semester we created an evaluation of its validity. The evaluation concluded that the model would need further development in the second semester. The reasoning behind this conclusion was the prior models reliance on intuitive measures and the lacking justification of its goals. The evaluation revealed that the proficiency modeling and the goals of an adaptive module hat to be checked against scientific evidence on the learning impact of self-adjusting difficulty models.  The problems the evaluation mentions are thus:

1. missing scientific backing for a positive learning impact,
2. missing scientific backing for the item difficulty classification,
3. no justification for the prioritization of weak player categories,
4. missing data for the evaluation of effectiveness.

### A shift to self-assessment neutralizes this problems by incorporating players self-regulation

We noticed that alternative self-adjusting models suffer the same justification problems as our old model, because the effectiveness of and justification for a self-adjusting adaption module is too dependent of the specific circumstances of its application. This meant we either had to research our models effectiveness ourselves or circumvent this problem otherwise.

Our solution was to accompany the self-adjusting model as it is with a model using player self-assessment to influence difficulty adaption. This relieved us of some of the above problems, as the player themselves can intervene, if they think difficulty level or category prioritization are not serving his learning goals. Thus the severity of inaccurate difficulty classification and improper category prioritization of the self-adjusting model is alleviated by players self-regulating behavior.

To prove the positive learning impact of the adaption module stays a goal of our team, as well as the collection of data to prove it. This need only increases with the addition of new features. Both is part of the data collection module that was also part of this semesters work.

## The new module unites a data driven approach with player self-regulation and the prior modules adaption processes

The main idea of this module is to create easy to understand *paths* that the player is able to choose from in order to make an informed decision about the further development of difficulty and prioritization during the task.

### The *path* selection choice after each task iteration is supposed to be data driven

The first interaction a player has with the path selection module is after the first task. The player is asked to choose a new *path* to influence the further development of the task after each iteration of any task. For the moment the player is provided with four options:

1. Increase all difficulties,
2. decrease all difficulties,
3. focus on a single category,
4. don't select a path.

While the first two options and the fourth are still generic we already choose the third option by identifying the task category the user took the longest to answer in the last iteration of task. We would like to extend this data driven approach in future versions of the module.

### Each path can influence both the difficulty and the probability with which every category is chosen

Each *path* consists out of  a `path_name`, an `path_id`, three dictionaries (`prof_dict`, `prob_dict`, `conditions`) and a boolean `set_prob` variable.

Clearly the `path_name` and the `path_id` are for identifying the path type.

The dictionary `prof_dict` encodes the change in proficiency the path is exerting.  For example the *increase all difficulties* path has the following dictionary: `{0.1 for all proficiencies in Vocabulary or Grammar}`. This means all proficiencies of the player are increased by 0.1 for this path.

The `prob_dict` dictionary encodes the change in probability the path is  exerting. For example the focus on a single category has the following dictionary: `{1 for chosen category 0 for other categories in Vocabulary or Grammar}`. This means the only category that has any probability is the chosen one. The `set_prob` variable handles two different methods of exerting the influence the path has on probability. Either it is set to `False` then the prioritization of the prior adaption module is left intact and only the values specified in the dictionary are changed or it is set to `True` then the prioritization of the prior adaption module is overridden and the specified values are set. All other values are equally distributed among the left over probability.

### This process is kept totally compatible with the prior adaption process

When a player chooses a path after a task it is registered in a `path` list in the student object of the player. Whenever a task item has to be chosen the priors model selection function is called (`selection.py`). If the player has *paths* in is `path` list these *paths* are used to influence the probability and the difficulty with which a category is selected.

First a category is selected. Either the probability is completely determined by the path. This happens, when a path has the `set_prob` attribute set to `True`. If this is the case only the last path with that property is valid and it dominates the probability distribution. The second case is all paths have `set_prob = False`. Then the probabilities of a path are added to the existing probabilities and then the probabilities are normed again. This happens in order of acquisition for all *paths*.

Second a difficulty is selected. The players proficiency for the selected category is added by the values of each *path*. If the proficiency exceeds 10 or drops below 0 it is kept constant. Now we proceed as in the prior model by balancing between category specific and domain average proficiency. 

### The story telling integration can be can be read in the according section

Lastly the new module was provided with a story telling integration. Read more about this in the story telling section of this semester.